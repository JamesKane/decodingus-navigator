package com.decodingus.genotype.parser

import com.decodingus.genotype.model.{GenotypeCall, TestTypeDefinition, TestTypes}

import java.io.{BufferedReader, File, FileReader}
import scala.util.{Try, Using}

/**
 * Result of detecting the file format.
 */
case class FormatDetectionResult(
                                  detected: Boolean,
                                  testType: Option[TestTypeDefinition],
                                  chipVersion: Option[String],
                                  headerLines: Int
                                )

/**
 * Base trait for chip data file parsers.
 *
 * The Edge App is responsible for parsing raw chip exports locally.
 * Raw genotype data never leaves the user's machine - only metadata
 * and Y/mtDNA variants are submitted to DecodingUs.
 *
 * @see multi-test-type-roadmap.md for data flow details
 */
trait ChipDataParser {

  /**
   * The vendor this parser handles.
   */
  def vendor: String

  /**
   * Supported file extensions.
   */
  def supportedExtensions: List[String]

  /**
   * Detect if this parser can handle the given file based on header lines.
   *
   * @param firstLines First few lines of the file
   * @return Detection result with test type and version info
   */
  def detect(firstLines: List[String]): FormatDetectionResult

  /**
   * Parse genotype calls from the file.
   *
   * @param file       The file to parse
   * @param onProgress Progress callback (current line, total lines estimate)
   * @return Iterator of genotype calls
   */
  def parse(file: File, onProgress: (Int, Int) => Unit = (_, _) => ()): Either[String, Iterator[GenotypeCall]]

  /**
   * Infer the chip version from the header.
   */
  def inferVersion(header: String): Option[String]
}

/**
 * Parser registry and auto-detection.
 */
object ChipDataParser {

  /**
   * All available parsers.
   */
  val parsers: List[ChipDataParser] = List(
    ParserBisdna,
    Parser23andMe,
    ParserAncestryDna,
    ParserFtdna,
    ParserMyHeritage,
    ParserLivingDna
  )

  /**
   * Auto-detect the appropriate parser for a file.
   *
   * @param file The file to detect
   * @return The appropriate parser and detection result
   */
  def detectParser(file: File): Either[String, (ChipDataParser, FormatDetectionResult)] = {
    readFirstLines(file, 20).flatMap { lines =>
      parsers.view
        .map(p => (p, p.detect(lines)))
        .find(_._2.detected)
        .toRight(s"Unknown file format. Unable to detect vendor from file header.")
    }
  }

  /**
   * Parse a chip data file with auto-detection.
   *
   * @param file       The file to parse
   * @param onProgress Progress callback
   * @return Either error or (parser, detection result, genotype calls)
   */
  def parseFile(
                 file: File,
                 onProgress: (Int, Int) => Unit = (_, _) => ()
               ): Either[String, (ChipDataParser, FormatDetectionResult, List[GenotypeCall])] = {
    detectParser(file).flatMap { case (parser, detection) =>
      parser.parse(file, onProgress).map { calls =>
        (parser, detection, calls.toList)
      }
    }
  }

  /**
   * Read the first N lines of a file for detection.
   */
  private def readFirstLines(file: File, n: Int): Either[String, List[String]] = {
    Try {
      Using.resource(new BufferedReader(new FileReader(file))) { reader =>
        Iterator.continually(reader.readLine())
          .takeWhile(_ != null)
          .take(n)
          .toList
      }
    }.toEither.left.map(e => s"Failed to read file: ${e.getMessage}")
  }
}

/**
 * Parser for 23andMe raw data exports.
 *
 * Format:
 * {{{
 * # This data file generated by 23andMe at: Wed Jan 01 2025 00:00:00 GMT+0000
 * #
 * # rsid  chromosome  position  genotype
 * rs12345	1	12345	AA
 * rs23456	1	23456	AG
 * }}}
 */
object Parser23andMe extends ChipDataParser {

  override def vendor: String = "23andMe"

  override def supportedExtensions: List[String] = List(".txt")

  override def detect(firstLines: List[String]): FormatDetectionResult = {
    val header = firstLines.mkString("\n").toLowerCase
    val is23andMe = header.contains("23andme") ||
      (header.contains("rsid") && header.contains("genotype") && !header.contains("allele1"))

    if (is23andMe) {
      val version = inferVersion(header)
      val testType = version match {
        case Some(v) if v.startsWith("5") => Some(TestTypes.ARRAY_23ANDME_V5)
        case Some(v) if v.startsWith("4") => Some(TestTypes.ARRAY_23ANDME_V4)
        case _ => Some(TestTypes.ARRAY_23ANDME_V5) // Default to v5
      }
      FormatDetectionResult(detected = true, testType = testType, chipVersion = version,
        headerLines = firstLines.takeWhile(_.startsWith("#")).size)
    } else {
      FormatDetectionResult(detected = false, testType = None, chipVersion = None, headerLines = 0)
    }
  }

  override def parse(file: File, onProgress: (Int, Int) => Unit): Either[String, Iterator[GenotypeCall]] = {
    Try {
      val reader = new BufferedReader(new FileReader(file))
      val lineCount = file.length() / 30 // Rough estimate

      var lineNumber = 0
      Iterator.continually(reader.readLine())
        .takeWhile(_ != null)
        .filterNot(_.startsWith("#"))
        .filterNot(_.trim.isEmpty)
        .flatMap { line =>
          lineNumber += 1
          if (lineNumber % 10000 == 0) onProgress(lineNumber, lineCount.toInt)
          parseLine(line)
        }
    }.toEither.left.map(e => s"Failed to parse 23andMe file: ${e.getMessage}")
  }

  private def parseLine(line: String): Option[GenotypeCall] = {
    val parts = line.split("\t")
    if (parts.length >= 4) {
      Try {
        val rsid = parts(0).trim
        val chr = parts(1).trim
        val pos = parts(2).trim.toInt
        val geno = parts(3).trim.toUpperCase

        if (geno.length >= 2) {
          Some(GenotypeCall(rsid, chr, pos, geno(0), geno(1)))
        } else if (geno.length == 1 && geno != "-") {
          // Haploid call
          Some(GenotypeCall(rsid, chr, pos, geno(0), geno(0)))
        } else {
          Some(GenotypeCall.noCall(rsid, chr, pos))
        }
      }.toOption.flatten
    } else None
  }

  override def inferVersion(header: String): Option[String] = {
    // Try to extract version from header comments
    val versionPattern = """v(\d+)""".r
    versionPattern.findFirstMatchIn(header.toLowerCase).map(_.group(1))
  }
}

/**
 * Parser for AncestryDNA raw data exports.
 *
 * Format:
 * {{{
 * #AncestryDNA raw data download
 * #This file was generated by AncestryDNA
 * rsid	chromosome	position	allele1	allele2
 * rs12345	1	12345	A	A
 * rs23456	1	23456	A	G
 * }}}
 */
object ParserAncestryDna extends ChipDataParser {

  override def vendor: String = "AncestryDNA"

  override def supportedExtensions: List[String] = List(".txt")

  override def detect(firstLines: List[String]): FormatDetectionResult = {
    val header = firstLines.mkString("\n").toLowerCase
    val isAncestry = header.contains("ancestrydna") ||
      (header.contains("rsid") && header.contains("allele1") && header.contains("allele2"))

    if (isAncestry) {
      FormatDetectionResult(
        detected = true,
        testType = Some(TestTypes.ARRAY_ANCESTRY_V2),
        chipVersion = inferVersion(header),
        headerLines = firstLines.takeWhile(l => l.startsWith("#") || l.toLowerCase.contains("rsid")).size
      )
    } else {
      FormatDetectionResult(detected = false, testType = None, chipVersion = None, headerLines = 0)
    }
  }

  override def parse(file: File, onProgress: (Int, Int) => Unit): Either[String, Iterator[GenotypeCall]] = {
    Try {
      val reader = new BufferedReader(new FileReader(file))
      val lineCount = file.length() / 25

      var lineNumber = 0
      var headerSkipped = false

      Iterator.continually(reader.readLine())
        .takeWhile(_ != null)
        .filterNot(_.startsWith("#"))
        .filterNot(_.trim.isEmpty)
        .flatMap { line =>
          lineNumber += 1
          if (lineNumber % 10000 == 0) onProgress(lineNumber, lineCount.toInt)

          // Skip the header line with column names
          if (!headerSkipped && line.toLowerCase.contains("rsid")) {
            headerSkipped = true
            None
          } else {
            headerSkipped = true
            parseLine(line)
          }
        }
    }.toEither.left.map(e => s"Failed to parse AncestryDNA file: ${e.getMessage}")
  }

  private def parseLine(line: String): Option[GenotypeCall] = {
    val parts = line.split("\t")
    if (parts.length >= 5) {
      Try {
        val rsid = parts(0).trim
        val chr = parts(1).trim
        val pos = parts(2).trim.toInt
        val a1 = parts(3).trim.toUpperCase
        val a2 = parts(4).trim.toUpperCase

        if (a1.nonEmpty && a2.nonEmpty && a1 != "0" && a2 != "0") {
          Some(GenotypeCall(rsid, chr, pos, a1(0), a2(0)))
        } else {
          Some(GenotypeCall.noCall(rsid, chr, pos))
        }
      }.toOption.flatten
    } else None
  }

  override def inferVersion(header: String): Option[String] = {
    if (header.contains("v2")) Some("2")
    else if (header.contains("v1")) Some("1")
    else Some("2") // Default to v2
  }
}

/**
 * Parser for FTDNA Family Finder raw data exports.
 *
 * Format:
 * {{{
 * RSID,CHROMOSOME,POSITION,RESULT
 * rs12345,1,12345,AA
 * rs23456,1,23456,AG
 * }}}
 */
object ParserFtdna extends ChipDataParser {

  override def vendor: String = "FamilyTreeDNA"

  override def supportedExtensions: List[String] = List(".csv")

  override def detect(firstLines: List[String]): FormatDetectionResult = {
    val header = firstLines.mkString("\n").toUpperCase
    val isFtdna = header.contains("RSID,CHROMOSOME,POSITION,RESULT") ||
      (header.contains("FTDNA") || header.contains("FAMILYTREEDNA"))

    if (isFtdna) {
      FormatDetectionResult(
        detected = true,
        testType = Some(TestTypes.ARRAY_FTDNA_FF),
        chipVersion = None,
        headerLines = 1
      )
    } else {
      FormatDetectionResult(detected = false, testType = None, chipVersion = None, headerLines = 0)
    }
  }

  override def parse(file: File, onProgress: (Int, Int) => Unit): Either[String, Iterator[GenotypeCall]] = {
    Try {
      val reader = new BufferedReader(new FileReader(file))
      val lineCount = file.length() / 20

      var lineNumber = 0
      var headerSkipped = false

      Iterator.continually(reader.readLine())
        .takeWhile(_ != null)
        .filterNot(_.trim.isEmpty)
        .flatMap { line =>
          lineNumber += 1
          if (lineNumber % 10000 == 0) onProgress(lineNumber, lineCount.toInt)

          if (!headerSkipped && line.toUpperCase.startsWith("RSID")) {
            headerSkipped = true
            None
          } else {
            headerSkipped = true
            parseLine(line)
          }
        }
    }.toEither.left.map(e => s"Failed to parse FTDNA file: ${e.getMessage}")
  }

  private def parseLine(line: String): Option[GenotypeCall] = {
    val parts = line.split(",")
    if (parts.length >= 4) {
      Try {
        val rsid = parts(0).trim
        val chr = parts(1).trim
        val pos = parts(2).trim.toInt
        val result = parts(3).trim.toUpperCase

        if (result.length >= 2) {
          Some(GenotypeCall(rsid, chr, pos, result(0), result(1)))
        } else if (result.length == 1 && result != "-") {
          Some(GenotypeCall(rsid, chr, pos, result(0), result(0)))
        } else {
          Some(GenotypeCall.noCall(rsid, chr, pos))
        }
      }.toOption.flatten
    } else None
  }

  override def inferVersion(header: String): Option[String] = None
}

/**
 * Parser for MyHeritage raw data exports.
 *
 * Format is similar to FTDNA CSV format.
 */
object ParserMyHeritage extends ChipDataParser {

  override def vendor: String = "MyHeritage"

  override def supportedExtensions: List[String] = List(".csv")

  override def detect(firstLines: List[String]): FormatDetectionResult = {
    val header = firstLines.mkString("\n").toLowerCase
    val isMyHeritage = header.contains("myheritage")

    if (isMyHeritage) {
      FormatDetectionResult(
        detected = true,
        testType = Some(TestTypes.ARRAY_MYHERITAGE),
        chipVersion = None,
        headerLines = firstLines.takeWhile(l => l.startsWith("#") || l.toLowerCase.contains("rsid")).size
      )
    } else {
      FormatDetectionResult(detected = false, testType = None, chipVersion = None, headerLines = 0)
    }
  }

  override def parse(file: File, onProgress: (Int, Int) => Unit): Either[String, Iterator[GenotypeCall]] = {
    // MyHeritage format is similar to FTDNA
    ParserFtdna.parse(file, onProgress)
  }

  override def inferVersion(header: String): Option[String] = None
}

/**
 * Parser for LivingDNA raw data exports.
 *
 * Format can vary but is typically similar to 23andMe.
 */
object ParserLivingDna extends ChipDataParser {

  override def vendor: String = "LivingDNA"

  override def supportedExtensions: List[String] = List(".csv", ".txt")

  override def detect(firstLines: List[String]): FormatDetectionResult = {
    val header = firstLines.mkString("\n").toLowerCase
    val isLivingDna = header.contains("livingdna") || header.contains("living dna")

    if (isLivingDna) {
      FormatDetectionResult(
        detected = true,
        testType = Some(TestTypes.ARRAY_LIVINGDNA),
        chipVersion = None,
        headerLines = firstLines.takeWhile(_.startsWith("#")).size
      )
    } else {
      FormatDetectionResult(detected = false, testType = None, chipVersion = None, headerLines = 0)
    }
  }

  override def parse(file: File, onProgress: (Int, Int) => Unit): Either[String, Iterator[GenotypeCall]] = {
    // Try 23andMe format first (tab-separated with genotype column)
    Parser23andMe.parse(file, onProgress)
  }

  override def inferVersion(header: String): Option[String] = None
}

/**
 * Parser for BISDNA Y-DNA chip data exports (chromo2 chip).
 *
 * BISDNA provides pre-interpreted Y-DNA SNP results. The file format is:
 * {{{
 * SNPID    genotype    result
 * CTS10003    CC    negative
 * M269    GG    positive
 * }}}
 *
 * Key differences from other chip parsers:
 * - Only Y-DNA markers (no autosomal/mtDNA)
 * - No position in file - must look up from DecodingUs variant database
 * - Result column provides lab interpretation (positive/negative/no_call/back-mutated)
 * - Genotypes are Illumina TOP strand, shown as diploid (GG = G) even though Y is haploid
 * - Heterozygous calls (e.g., "AG") indicate positive due to Illumina clustering
 *
 * This parser uses the genotype column to determine derived/ancestral status
 * by comparing against ref/alt from the DecodingUs variant database.
 */
object ParserBisdna extends ChipDataParser {

  import com.decodingus.haplogroup.vendor.NamedVariantCache

  override def vendor: String = "BISDNA"

  override def supportedExtensions: List[String] = List(".txt", ".csv", ".tsv")

  override def detect(firstLines: List[String]): FormatDetectionResult = {
    // Look for the characteristic BISDNA header: SNPID<tab>genotype<tab>result
    val headerLine = firstLines.find { line =>
      val lower = line.toLowerCase.trim
      lower.startsWith("snpid") && lower.contains("genotype") && lower.contains("result")
    }

    headerLine match {
      case Some(_) =>
        FormatDetectionResult(
          detected = true,
          testType = Some(TestTypes.ARRAY_BISDNA),
          chipVersion = Some("chromo2"),
          headerLines = 1
        )
      case None =>
        FormatDetectionResult(detected = false, testType = None, chipVersion = None, headerLines = 0)
    }
  }

  override def parse(file: File, onProgress: (Int, Int) => Unit): Either[String, Iterator[GenotypeCall]] = {
    // Ensure the variant cache is loaded first
    val cache = NamedVariantCache()
    cache.ensureLoaded(msg => println(s"[ParserBisdna] $msg")) match {
      case Left(error) =>
        return Left(s"Failed to load variant database: $error. Cannot parse BISDNA file without position lookups.")
      case Right(_) => // continue
    }

    Try {
      val reader = new BufferedReader(new FileReader(file))
      val lineCount = file.length() / 30 // Rough estimate

      var lineNumber = 0
      var headerSkipped = false

      Iterator.continually(reader.readLine())
        .takeWhile(_ != null)
        .filterNot(_.trim.isEmpty)
        .flatMap { line =>
          lineNumber += 1
          if (lineNumber % 1000 == 0) onProgress(lineNumber, lineCount.toInt)

          // Skip header line
          if (!headerSkipped && line.toLowerCase.startsWith("snpid")) {
            headerSkipped = true
            None
          } else {
            headerSkipped = true
            parseLine(line, cache)
          }
        }
    }.toEither.left.map(e => s"Failed to parse BISDNA file: ${e.getMessage}")
  }

  /**
   * Parse a single BISDNA data line.
   *
   * Format: SNPID<tab>genotype<tab>result
   * Example: CTS10003    CC    negative
   *
   * Genotype interpretation (per BISDNA documentation):
   * - Homozygous (AA, GG, CC, TT): The actual allele (A, G, C, or T)
   * - Heterozygous (AG, CT, etc.): Due to Illumina clustering limitations on Y,
   *   het calls indicate a POSITIVE/DERIVED call. Use the alt allele from the database.
   * - Back-mutations: Result column shows "back-mutated" - ancestral reversion cases
   *
   * We use the genotype to determine the allele, and look up the position
   * from the DecodingUs variant database.
   */
  private def parseLine(line: String, cache: NamedVariantCache): Option[GenotypeCall] = {
    val parts = line.split("\t")
    if (parts.length >= 2) {
      val snpName = parts(0).trim
      val genotypeStr = parts(1).trim.toUpperCase
      val resultStr = if (parts.length >= 3) parts(2).trim.toLowerCase else ""

      // Skip no-call entries
      if (genotypeStr == "0" || genotypeStr == "00" || genotypeStr.isEmpty || resultStr == "no_call") {
        return None
      }

      // Look up this SNP in the variant database
      cache.getByName(snpName) match {
        case Some(variant) =>
          // Get GRCh38 coordinates (or fall back to GRCh37)
          val coord = variant.coordinateFor("GRCh38")
            .orElse(variant.coordinateFor("GRCh37"))

          coord.map { c =>
            // Determine the allele based on genotype pattern
            val allele: Char = if (genotypeStr.length >= 2 && genotypeStr(0) != genotypeStr(1)) {
              // Heterozygous call (e.g., "AG") - Illumina clustering artifact
              // Per BISDNA: het calls on Y indicate POSITIVE/DERIVED
              // Use the alt (derived) allele from the variant database
              if (c.alt.nonEmpty) c.alt.head else genotypeStr(0)
            } else if (resultStr == "back-mutated") {
              // Back-mutation case - sample has reverted to ancestral
              // Use the ref (ancestral) allele
              if (c.ref.nonEmpty) c.ref.head else genotypeStr(0)
            } else {
              // Homozygous call (AA, GG, CC, TT) - the actual allele
              if (genotypeStr.nonEmpty) genotypeStr(0) else '-'
            }

            GenotypeCall(
              markerId = snpName,
              chromosome = "Y",
              position = c.position,
              allele1 = allele,
              allele2 = allele
            )
          }

        case None =>
          // SNP not found in database - skip it
          // This is expected for some markers that may be vendor-specific
          None
      }
    } else None
  }

  override def inferVersion(header: String): Option[String] = Some("chromo2")
}
