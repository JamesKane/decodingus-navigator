package com.decodingus.genotype.parser

import com.decodingus.genotype.model.{GenotypeCall, TestTypeDefinition, TestTypes}

import java.io.{BufferedReader, File, FileReader}
import scala.util.{Try, Using}

/**
 * Result of detecting the file format.
 */
case class FormatDetectionResult(
                                  detected: Boolean,
                                  testType: Option[TestTypeDefinition],
                                  chipVersion: Option[String],
                                  headerLines: Int
                                )

/**
 * Base trait for chip data file parsers.
 *
 * The Edge App is responsible for parsing raw chip exports locally.
 * Raw genotype data never leaves the user's machine - only metadata
 * and Y/mtDNA variants are submitted to DecodingUs.
 *
 * @see multi-test-type-roadmap.md for data flow details
 */
trait ChipDataParser {

  /**
   * The vendor this parser handles.
   */
  def vendor: String

  /**
   * Supported file extensions.
   */
  def supportedExtensions: List[String]

  /**
   * Detect if this parser can handle the given file based on header lines.
   *
   * @param firstLines First few lines of the file
   * @return Detection result with test type and version info
   */
  def detect(firstLines: List[String]): FormatDetectionResult

  /**
   * Parse genotype calls from the file.
   *
   * @param file       The file to parse
   * @param onProgress Progress callback (current line, total lines estimate)
   * @return Iterator of genotype calls
   */
  def parse(file: File, onProgress: (Int, Int) => Unit = (_, _) => ()): Either[String, Iterator[GenotypeCall]]

  /**
   * Infer the chip version from the header.
   */
  def inferVersion(header: String): Option[String]
}

/**
 * Parser registry and auto-detection.
 */
object ChipDataParser {

  /**
   * All available parsers.
   */
  val parsers: List[ChipDataParser] = List(
    Parser23andMe,
    ParserAncestryDna,
    ParserFtdna,
    ParserMyHeritage,
    ParserLivingDna
  )

  /**
   * Auto-detect the appropriate parser for a file.
   *
   * @param file The file to detect
   * @return The appropriate parser and detection result
   */
  def detectParser(file: File): Either[String, (ChipDataParser, FormatDetectionResult)] = {
    readFirstLines(file, 20).flatMap { lines =>
      parsers.view
        .map(p => (p, p.detect(lines)))
        .find(_._2.detected)
        .toRight(s"Unknown file format. Unable to detect vendor from file header.")
    }
  }

  /**
   * Parse a chip data file with auto-detection.
   *
   * @param file       The file to parse
   * @param onProgress Progress callback
   * @return Either error or (parser, detection result, genotype calls)
   */
  def parseFile(
                 file: File,
                 onProgress: (Int, Int) => Unit = (_, _) => ()
               ): Either[String, (ChipDataParser, FormatDetectionResult, List[GenotypeCall])] = {
    detectParser(file).flatMap { case (parser, detection) =>
      parser.parse(file, onProgress).map { calls =>
        (parser, detection, calls.toList)
      }
    }
  }

  /**
   * Read the first N lines of a file for detection.
   */
  private def readFirstLines(file: File, n: Int): Either[String, List[String]] = {
    Try {
      Using.resource(new BufferedReader(new FileReader(file))) { reader =>
        Iterator.continually(reader.readLine())
          .takeWhile(_ != null)
          .take(n)
          .toList
      }
    }.toEither.left.map(e => s"Failed to read file: ${e.getMessage}")
  }
}

/**
 * Parser for 23andMe raw data exports.
 *
 * Format:
 * {{{
 * # This data file generated by 23andMe at: Wed Jan 01 2025 00:00:00 GMT+0000
 * #
 * # rsid  chromosome  position  genotype
 * rs12345	1	12345	AA
 * rs23456	1	23456	AG
 * }}}
 */
object Parser23andMe extends ChipDataParser {

  override def vendor: String = "23andMe"

  override def supportedExtensions: List[String] = List(".txt")

  override def detect(firstLines: List[String]): FormatDetectionResult = {
    val header = firstLines.mkString("\n").toLowerCase
    val is23andMe = header.contains("23andme") ||
      (header.contains("rsid") && header.contains("genotype") && !header.contains("allele1"))

    if (is23andMe) {
      val version = inferVersion(header)
      val testType = version match {
        case Some(v) if v.startsWith("5") => Some(TestTypes.ARRAY_23ANDME_V5)
        case Some(v) if v.startsWith("4") => Some(TestTypes.ARRAY_23ANDME_V4)
        case _ => Some(TestTypes.ARRAY_23ANDME_V5) // Default to v5
      }
      FormatDetectionResult(detected = true, testType = testType, chipVersion = version,
        headerLines = firstLines.takeWhile(_.startsWith("#")).size)
    } else {
      FormatDetectionResult(detected = false, testType = None, chipVersion = None, headerLines = 0)
    }
  }

  override def parse(file: File, onProgress: (Int, Int) => Unit): Either[String, Iterator[GenotypeCall]] = {
    Try {
      val reader = new BufferedReader(new FileReader(file))
      val lineCount = file.length() / 30 // Rough estimate

      var lineNumber = 0
      Iterator.continually(reader.readLine())
        .takeWhile(_ != null)
        .filterNot(_.startsWith("#"))
        .filterNot(_.trim.isEmpty)
        .flatMap { line =>
          lineNumber += 1
          if (lineNumber % 10000 == 0) onProgress(lineNumber, lineCount.toInt)
          parseLine(line)
        }
    }.toEither.left.map(e => s"Failed to parse 23andMe file: ${e.getMessage}")
  }

  private def parseLine(line: String): Option[GenotypeCall] = {
    val parts = line.split("\t")
    if (parts.length >= 4) {
      Try {
        val rsid = parts(0).trim
        val chr = parts(1).trim
        val pos = parts(2).trim.toInt
        val geno = parts(3).trim.toUpperCase

        if (geno.length >= 2) {
          Some(GenotypeCall(rsid, chr, pos, geno(0), geno(1)))
        } else if (geno.length == 1 && geno != "-") {
          // Haploid call
          Some(GenotypeCall(rsid, chr, pos, geno(0), geno(0)))
        } else {
          Some(GenotypeCall.noCall(rsid, chr, pos))
        }
      }.toOption.flatten
    } else None
  }

  override def inferVersion(header: String): Option[String] = {
    // Try to extract version from header comments
    val versionPattern = """v(\d+)""".r
    versionPattern.findFirstMatchIn(header.toLowerCase).map(_.group(1))
  }
}

/**
 * Parser for AncestryDNA raw data exports.
 *
 * Format:
 * {{{
 * #AncestryDNA raw data download
 * #This file was generated by AncestryDNA
 * rsid	chromosome	position	allele1	allele2
 * rs12345	1	12345	A	A
 * rs23456	1	23456	A	G
 * }}}
 */
object ParserAncestryDna extends ChipDataParser {

  override def vendor: String = "AncestryDNA"

  override def supportedExtensions: List[String] = List(".txt")

  override def detect(firstLines: List[String]): FormatDetectionResult = {
    val header = firstLines.mkString("\n").toLowerCase
    val isAncestry = header.contains("ancestrydna") ||
      (header.contains("rsid") && header.contains("allele1") && header.contains("allele2"))

    if (isAncestry) {
      FormatDetectionResult(
        detected = true,
        testType = Some(TestTypes.ARRAY_ANCESTRY_V2),
        chipVersion = inferVersion(header),
        headerLines = firstLines.takeWhile(l => l.startsWith("#") || l.toLowerCase.contains("rsid")).size
      )
    } else {
      FormatDetectionResult(detected = false, testType = None, chipVersion = None, headerLines = 0)
    }
  }

  override def parse(file: File, onProgress: (Int, Int) => Unit): Either[String, Iterator[GenotypeCall]] = {
    Try {
      val reader = new BufferedReader(new FileReader(file))
      val lineCount = file.length() / 25

      var lineNumber = 0
      var headerSkipped = false

      Iterator.continually(reader.readLine())
        .takeWhile(_ != null)
        .filterNot(_.startsWith("#"))
        .filterNot(_.trim.isEmpty)
        .flatMap { line =>
          lineNumber += 1
          if (lineNumber % 10000 == 0) onProgress(lineNumber, lineCount.toInt)

          // Skip the header line with column names
          if (!headerSkipped && line.toLowerCase.contains("rsid")) {
            headerSkipped = true
            None
          } else {
            headerSkipped = true
            parseLine(line)
          }
        }
    }.toEither.left.map(e => s"Failed to parse AncestryDNA file: ${e.getMessage}")
  }

  private def parseLine(line: String): Option[GenotypeCall] = {
    val parts = line.split("\t")
    if (parts.length >= 5) {
      Try {
        val rsid = parts(0).trim
        val chr = parts(1).trim
        val pos = parts(2).trim.toInt
        val a1 = parts(3).trim.toUpperCase
        val a2 = parts(4).trim.toUpperCase

        if (a1.nonEmpty && a2.nonEmpty && a1 != "0" && a2 != "0") {
          Some(GenotypeCall(rsid, chr, pos, a1(0), a2(0)))
        } else {
          Some(GenotypeCall.noCall(rsid, chr, pos))
        }
      }.toOption.flatten
    } else None
  }

  override def inferVersion(header: String): Option[String] = {
    if (header.contains("v2")) Some("2")
    else if (header.contains("v1")) Some("1")
    else Some("2") // Default to v2
  }
}

/**
 * Parser for FTDNA Family Finder raw data exports.
 *
 * Format:
 * {{{
 * RSID,CHROMOSOME,POSITION,RESULT
 * rs12345,1,12345,AA
 * rs23456,1,23456,AG
 * }}}
 */
object ParserFtdna extends ChipDataParser {

  override def vendor: String = "FamilyTreeDNA"

  override def supportedExtensions: List[String] = List(".csv")

  override def detect(firstLines: List[String]): FormatDetectionResult = {
    val header = firstLines.mkString("\n").toUpperCase
    val isFtdna = header.contains("RSID,CHROMOSOME,POSITION,RESULT") ||
      (header.contains("FTDNA") || header.contains("FAMILYTREEDNA"))

    if (isFtdna) {
      FormatDetectionResult(
        detected = true,
        testType = Some(TestTypes.ARRAY_FTDNA_FF),
        chipVersion = None,
        headerLines = 1
      )
    } else {
      FormatDetectionResult(detected = false, testType = None, chipVersion = None, headerLines = 0)
    }
  }

  override def parse(file: File, onProgress: (Int, Int) => Unit): Either[String, Iterator[GenotypeCall]] = {
    Try {
      val reader = new BufferedReader(new FileReader(file))
      val lineCount = file.length() / 20

      var lineNumber = 0
      var headerSkipped = false

      Iterator.continually(reader.readLine())
        .takeWhile(_ != null)
        .filterNot(_.trim.isEmpty)
        .flatMap { line =>
          lineNumber += 1
          if (lineNumber % 10000 == 0) onProgress(lineNumber, lineCount.toInt)

          if (!headerSkipped && line.toUpperCase.startsWith("RSID")) {
            headerSkipped = true
            None
          } else {
            headerSkipped = true
            parseLine(line)
          }
        }
    }.toEither.left.map(e => s"Failed to parse FTDNA file: ${e.getMessage}")
  }

  private def parseLine(line: String): Option[GenotypeCall] = {
    val parts = line.split(",")
    if (parts.length >= 4) {
      Try {
        val rsid = parts(0).trim
        val chr = parts(1).trim
        val pos = parts(2).trim.toInt
        val result = parts(3).trim.toUpperCase

        if (result.length >= 2) {
          Some(GenotypeCall(rsid, chr, pos, result(0), result(1)))
        } else if (result.length == 1 && result != "-") {
          Some(GenotypeCall(rsid, chr, pos, result(0), result(0)))
        } else {
          Some(GenotypeCall.noCall(rsid, chr, pos))
        }
      }.toOption.flatten
    } else None
  }

  override def inferVersion(header: String): Option[String] = None
}

/**
 * Parser for MyHeritage raw data exports.
 *
 * Format is similar to FTDNA CSV format.
 */
object ParserMyHeritage extends ChipDataParser {

  override def vendor: String = "MyHeritage"

  override def supportedExtensions: List[String] = List(".csv")

  override def detect(firstLines: List[String]): FormatDetectionResult = {
    val header = firstLines.mkString("\n").toLowerCase
    val isMyHeritage = header.contains("myheritage")

    if (isMyHeritage) {
      FormatDetectionResult(
        detected = true,
        testType = Some(TestTypes.ARRAY_MYHERITAGE),
        chipVersion = None,
        headerLines = firstLines.takeWhile(l => l.startsWith("#") || l.toLowerCase.contains("rsid")).size
      )
    } else {
      FormatDetectionResult(detected = false, testType = None, chipVersion = None, headerLines = 0)
    }
  }

  override def parse(file: File, onProgress: (Int, Int) => Unit): Either[String, Iterator[GenotypeCall]] = {
    // MyHeritage format is similar to FTDNA
    ParserFtdna.parse(file, onProgress)
  }

  override def inferVersion(header: String): Option[String] = None
}

/**
 * Parser for LivingDNA raw data exports.
 *
 * Format can vary but is typically similar to 23andMe.
 */
object ParserLivingDna extends ChipDataParser {

  override def vendor: String = "LivingDNA"

  override def supportedExtensions: List[String] = List(".csv", ".txt")

  override def detect(firstLines: List[String]): FormatDetectionResult = {
    val header = firstLines.mkString("\n").toLowerCase
    val isLivingDna = header.contains("livingdna") || header.contains("living dna")

    if (isLivingDna) {
      FormatDetectionResult(
        detected = true,
        testType = Some(TestTypes.ARRAY_LIVINGDNA),
        chipVersion = None,
        headerLines = firstLines.takeWhile(_.startsWith("#")).size
      )
    } else {
      FormatDetectionResult(detected = false, testType = None, chipVersion = None, headerLines = 0)
    }
  }

  override def parse(file: File, onProgress: (Int, Int) => Unit): Either[String, Iterator[GenotypeCall]] = {
    // Try 23andMe format first (tab-separated with genotype column)
    Parser23andMe.parse(file, onProgress)
  }

  override def inferVersion(header: String): Option[String] = None
}
